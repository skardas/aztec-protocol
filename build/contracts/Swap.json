{
  "contractName": "Swap",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[6]",
          "name": "",
          "type": "uint256[6]"
        }
      ],
      "name": "validateSwap",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.5.17+commit.d19bba13\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}],\"devdoc\":{\"author\":\"AZTEC\",\"details\":\"Library to validate Swap proofs Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes. Calling this internally from another function will lead to memory mutation and undefined behaviour. The intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)  * Copyright 2020 Spilsbury Holdings Ltd  * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \\\"License\\\"); you may not use this file except in compliance with the License. * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details. * You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.*\",\"methods\":{},\"title\":\"Swap\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/Swap.sol\":\"Swap\"},\"evmVersion\":\"petersburg\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/Swap.sol\":{\"keccak256\":\"0x12be40c1d9ba8b14886488b44c704dca0cfa224528ed3261463db4b6f896c083\",\"urls\":[\"bzz-raw://f1b4b61875e576b3026c5e354457d949108b619468fc1d51c267d92a0a02fd27\",\"dweb:/ipfs/QmRVjt72V1CtXBToNiZ1a8mqMwBVuLYk5D9THpSQivCWSi\"]},\"/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/SwapABIEncoder.sol\":{\"keccak256\":\"0x5f91754f15202af4cda76744cbd749b7c798ca34e45078fb1b7a75446069769e\",\"urls\":[\"bzz-raw://ba11d958acf87de38062ec978554780039aa64da152f45edce368704e98bf58d\",\"dweb:/ipfs/QmSvv2hjGNMQNjnCgNEeunufvTYQJD12wAfzjynqo9p7rZ\"]}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506107ed806100206000396000f3fe608060405234801561001057600080fd5b50610019610023565b60606040526104db565b60443560805260643560a052610144356101040180356004811461004d5761019060005260206000fd5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061012435066024356102e05261008583856104a4565b6080830261030001600160005b858110156102075760c081026020880101600060208201358660018511600181146100c25780156100cf576100d4565b61018085033593506100d4565b843593505b506100e08284866103fc565b88600051870995508415610101578886840992508886830991508886890990505b60406080850160e037604080850160203780890361012052826060528160c05260406101a0606060e060075afa60406101206060602060075afa1660406101606060608060075afa166040610160608061012060065afa16604088608061016060065afa16856101ab57602051610260526040516102805260e0516101e052610100517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4703610200525b85156101e2578160605260406102206060602060075afa6040610260608061022060065afa60406101e060806101a060065afa1616165b806101f35761019060005260206000fd5b505050604094909401935050600101610092565b506102126084610239565b836102e083036102e020068381146102305761019460005260206000fd5b50505050505050565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4781356020830135604084013560608501357f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81147f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa83147f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c285147f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed87148415861588158a1517171717171717156103175761019060005260206000fd5b6101e051602052610200516040527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6080527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26060527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60c0527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b60a0526102605160e05261028051610100528361014052826101205281610180528061016052602080610180602060085afa60205115811517156102305761019060005260206000fd5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760408301356060840135608085013560a086013584838409856003878789898a090908148582830986600388868a888909090814166001891189888b06141660018b118b898d06141616166104995761019060005260206000fd5b505050505050505050565b60005b828110156104cd57606060c08202830101608081608084026103000137506001016104a7565b505060800261030020600052565b6104e36104e5565b005b610144356101040161016435610124016101843561014401602082033560041460208203356002141661051757600080fd5b60206101605260026101a05260806101c05260c06102205261020061024052600061026052600061028052610124356102a0526101206102c05260016102e052606061030052600160005260806060840160203760c06103205260016103405281356103605260a06000206103805260406103a052600160ff1b60016040511602602051176103c052600160ff1b60016080511602606051176103e05260016104205260606104405260806101e0840160203760016104805260408201356104a05260a06000206104c052803560408203810135806040016104e052600160ff1b600160405116026020511761050052600160ff1b60016080511602606051176105205280602084038301610540378060c00161046052806101200161040052806103200161020052806103c0016101e052806105400160c06020820152610200604082015260006060820152600060808201526101243560e052602060e02060a082015261012060c0820152600160e0820152606061010082015260806102a0870160203760c06101208201526001610140820152606085013561016082015260a060002061018082015260406101a0820152600160ff1b60016040511602602051176101c0820152600160ff1b60016080511602606051176101e08201526001610220820152606061024082015260806101208701602037600161028082015260208501356102a082015260a06000206102c082015260208401359250604084038301359150816040016102e0820152600160ff1b6001604051160260205117610300820152600160ff1b6001608051160260605117610320820152816020850384016103408301378160c00161026082015281610120016102008201528161032001815261020051826103c001016101805260406101805101610160f3fea265627a7a72315820875ed2de7839ba3dc417eeca9f54b93b94967ba1e72f860a03864a1b77b2606664736f6c63430005110032",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50610019610023565b60606040526104db565b60443560805260643560a052610144356101040180356004811461004d5761019060005260206000fd5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061012435066024356102e05261008583856104a4565b6080830261030001600160005b858110156102075760c081026020880101600060208201358660018511600181146100c25780156100cf576100d4565b61018085033593506100d4565b843593505b506100e08284866103fc565b88600051870995508415610101578886840992508886830991508886890990505b60406080850160e037604080850160203780890361012052826060528160c05260406101a0606060e060075afa60406101206060602060075afa1660406101606060608060075afa166040610160608061012060065afa16604088608061016060065afa16856101ab57602051610260526040516102805260e0516101e052610100517f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4703610200525b85156101e2578160605260406102206060602060075afa6040610260608061022060065afa60406101e060806101a060065afa1616165b806101f35761019060005260206000fd5b505050604094909401935050600101610092565b506102126084610239565b836102e083036102e020068381146102305761019460005260206000fd5b50505050505050565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4781356020830135604084013560608501357f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81147f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa83147f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c285147f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed87148415861588158a1517171717171717156103175761019060005260206000fd5b6101e051602052610200516040527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6080527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26060527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60c0527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b60a0526102605160e05261028051610100528361014052826101205281610180528061016052602080610180602060085afa60205115811517156102305761019060005260206000fd5b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760408301356060840135608085013560a086013584838409856003878789898a090908148582830986600388868a888909090814166001891189888b06141660018b118b898d06141616166104995761019060005260206000fd5b505050505050505050565b60005b828110156104cd57606060c08202830101608081608084026103000137506001016104a7565b505060800261030020600052565b6104e36104e5565b005b610144356101040161016435610124016101843561014401602082033560041460208203356002141661051757600080fd5b60206101605260026101a05260806101c05260c06102205261020061024052600061026052600061028052610124356102a0526101206102c05260016102e052606061030052600160005260806060840160203760c06103205260016103405281356103605260a06000206103805260406103a052600160ff1b60016040511602602051176103c052600160ff1b60016080511602606051176103e05260016104205260606104405260806101e0840160203760016104805260408201356104a05260a06000206104c052803560408203810135806040016104e052600160ff1b600160405116026020511761050052600160ff1b60016080511602606051176105205280602084038301610540378060c00161046052806101200161040052806103200161020052806103c0016101e052806105400160c06020820152610200604082015260006060820152600060808201526101243560e052602060e02060a082015261012060c0820152600160e0820152606061010082015260806102a0870160203760c06101208201526001610140820152606085013561016082015260a060002061018082015260406101a0820152600160ff1b60016040511602602051176101c0820152600160ff1b60016080511602606051176101e08201526001610220820152606061024082015260806101208701602037600161028082015260208501356102a082015260a06000206102c082015260208401359250604084038301359150816040016102e0820152600160ff1b6001604051160260205117610300820152600160ff1b6001608051160260605117610320820152816020850384016103408301378160c00161026082015281610120016102008201528161032001815261020051826103c001016101805260406101805101610160f3fea265627a7a72315820875ed2de7839ba3dc417eeca9f54b93b94967ba1e72f860a03864a1b77b2606664736f6c63430005110032",
  "sourceMap": "1235:16849:30:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1235:16849:30;;;;;;;",
  "deployedSourceMap": "1235:16849:30:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1235:16849:30;1987:14;;;;2268:4;2262;2255:18;4651:6980;;;4873:4;4860:18;4854:4;4847:32;4929:4;4916:18;4910:4;4903:32;4996:5;4983:19;4976:5;4972:31;5069:5;5056:19;5160:4;5157:1;5154:11;5144:2;;5243:3;5237:4;5230:17;5343:4;5337;5330:18;5144:2;5402:66;5527:9;5519:5;5506:19;5502:35;5582:4;5569:18;5562:5;5555:33;5650:25;5673:1;5666:5;5650:25;;;5719:4;5716:1;5712:12;5705:5;5701:24;5972:1;6126;6111:4741;6136:1;6133;6130:8;6111:4741;;;6315:4;6312:1;6308:12;6301:4;6294:5;6290:16;6286:35;;6405:4;6394:9;6390:20;6377:34;6441:9;6485:1;6482;6479:8;6556:1;6551:222;;;;6795:107;;;;6472:430;;6551:222;6744:5;6733:9;6729:21;6716:35;6711:40;;6551:222;;6795:107;6870:9;6857:23;6852:28;;6472:430;;6985:35;7018:1;7015;7004:9;6985:35;;;7070:9;7063:4;7057:11;7054:1;7047:33;7042:38;-1:-1:-1;7182:8:30;;7179:2;;7235:9;7232:1;7229;7222:23;7217:28;;7288:9;7285:1;7282;7275:23;7270:28;;7349:9;7346:1;7335:9;7328:31;7323:36;;7179:2;7929:4;7922;7911:9;7907:20;7901:4;7888:46;7996:4;7989;7978:9;7974:20;7968:4;7955:46;8051:1;8040:9;8036:17;8029:5;8022:32;8088:1;8082:4;8075:15;8124:1;8118:4;8111:15;8530:4;8523:5;8517:4;8511;8508:1;8503:3;8492:43;8616:4;8609:5;8603:4;8597;8594:1;8589:3;8578:43;8566:56;8703:4;8696:5;8690:4;8684;8681:1;8676:3;8665:43;8653:56;8990:4;8983:5;8977:4;8970:5;8967:1;8962:3;8951:44;8939:57;9225:4;9222:1;9216:4;9209:5;9206:1;9201:3;9190:40;9178:53;9256:8;9253:2;;9320:4;9314:11;9307:5;9300:26;9384:4;9378:11;9371:5;9364:26;9447:4;9441:11;9434:5;9427:26;9639:5;9633:12;9565:66;9561:85;9526:5;9490:186;9253:2;9983:8;;9980:2;;10031:1;10025:4;10018:15;10499:4;10492:5;10486:4;10480;10477:1;10472:3;10461:43;10363:4;10356:5;10350:4;10343:5;10340:1;10335:3;10324:44;10255:4;10248:5;10242:4;10235:5;10232:1;10227:3;10216:44;10175:252;10138:410;10069:505;9980:2;10715:6;10705:2;;10738:3;10732:4;10725:17;10756:4;10750;10743:18;10705:2;-1:-1:-1;;;10796:4:30;10789:12;;;;;-1:-1:-1;;6153:4:30;6146:12;6111:4741;;;6115:14;10886:21;10902:4;10886:21;;;11408:9;11399:5;11396:1;11392:13;11385:5;11375:31;11371:47;11459:9;11449:8;11446:23;11436:2;;11556:3;11550:4;11543:17;11594:4;11588;11581:18;11436:2;4675:6956;;;;;;;;11882:2508;11948:66;12058:2;12045:16;12113:4;12109:2;12105:13;12092:27;12171:4;12167:2;12163:13;12150:27;12229:4;12225:2;12221:13;12208:27;12824:65;12816:6;12813:77;12723:66;12715:6;12712:78;12622:66;12614:6;12611:78;12521:66;12513:6;12510:78;12480:6;12473:14;12443:6;12436:14;12406:6;12399:14;12370:6;12363:14;12339:75;12336:115;12333:155;12330:259;12327:363;12324:467;12321:570;12318:2;;;12943:3;12937:4;12930:17;12981:4;12975;12968:18;12318:2;13374:5;13368:12;13362:4;13355:26;13440:5;13434:12;13428:4;13421:26;13500:66;13494:4;13487:80;13597:66;13591:4;13584:80;13694:66;13688:4;13681:80;13791:65;13785:4;13778:79;13893:5;13887:12;13881:4;13874:26;13960:5;13954:12;13947:5;13940:27;14021:6;14014:5;14007:21;14059:6;14052:5;14045:21;14097:6;14090:5;14083:21;14135:6;14128:5;14121:21;14213:4;14207;14200:5;14194:4;14191:1;14186:3;14175:43;14272:4;14266:11;14259:19;14249:7;14242:15;14239:40;14236:2;;;14315:3;14309:4;14302:17;14353:4;14347;14340:18;14729:2060;14804:66;14906;15026:4;15020;15016:15;15003:29;15086:4;15080;15076:15;15063:29;15146:4;15140;15136:15;15123:29;15206:4;15200;15196:15;15183:29;16570:11;16562:6;16554;16547:35;16501:11;16498:1;16448:11;16404:6;16354:11;16346:6;16338;16331:35;16287:173;16280:233;16226:386;16154:11;16146:6;16138;16131:35;16085:11;16046:1;15996:11;15988:6;15974:11;15966:6;15958;15951:35;15907:101;15900:197;15846:350;15813:825;15694:1;15691;15688:8;15620:1;15608:9;15605:1;15601:17;15598:24;15561:200;15455:1;15452;15449:8;15381:1;15369:9;15366:1;15362:17;15359:24;15322:209;15289:498;15260:1400;15229:2;;16714:3;16708:4;16701:17;16752:4;16746;16739:18;15229:2;14769:2020;;;;;;;;;;17395:474;17463:1;17448:202;17473:1;17470;17467:8;17448:202;;;17559:4;17551;17548:1;17544:12;17537:5;17533:24;17529:35;17627:4;17620:5;17612:4;17609:1;17605:12;17598:5;17594:24;17581:51;-1:-1:-1;17490:4:30;17483:12;17448:202;;;-1:-1:-1;;17848:4:30;17841:12;17834:5;17824:30;17818:4;17811:44;17430:439;;18045:30;:28;:30::i;:::-;1235:16849;1991:26025:31;2140:5;2127:19;2120:5;2116:31;2202:5;2189:19;2182:5;2178:31;2304:5;2291:19;2284:5;2280:31;2775:4;2763:10;2759:21;2746:35;2740:4;2737:45;2712:4;2699:11;2695:22;2682:36;2676:4;2673:46;2652:144;2642:2;;2829:4;2823;2816:18;2642:2;6069:4;6062:5;6055:19;6842:4;6835:5;6828:19;6990:4;6983:5;6976:19;7811:4;7804:5;7797:19;8195:5;8188;8181:20;8374:4;8367:5;8360:19;8449:4;8442:5;8435:19;8537:5;8524:19;8517:5;8510:34;9425:5;9418;9411:20;9502:4;9495:5;9488:19;9611:4;9604:5;9597:19;10433:4;10427;10420:18;10905:4;10898;10891:5;10887:16;10881:4;10868:42;11021:4;11014:5;11007:19;11105:4;11098:5;11091:19;11265:10;11252:24;11245:5;11238:39;11414:4;11408;11398:21;11391:5;11384:36;11520:4;11513:5;11506:19;-1:-1:-1;;;12441:4:31;12434;12428:11;12424:22;12352:208;12304:4;12298:11;12274:304;12251:5;12227:365;-1:-1:-1;;;12781:4:31;12774;12768:11;12764:22;12739:157;12712:4;12706:11;12682:232;12659:5;12635:293;13650:4;13643:5;13636:19;13749:4;13742:5;13735:19;15041:4;15033:5;15026;15022:17;15016:4;15003:43;15206:4;15199:5;15192:19;15445:4;15433:10;15429:21;15416:35;15409:5;15402:50;15543:4;15537;15527:21;15520:5;15513:36;15971:11;15958:25;17125:4;17112:11;17108:22;17093:13;17089:42;17076:56;17234:14;17228:4;17224:25;17217:5;17210:40;-1:-1:-1;;;17470:4:31;17463;17457:11;17453:22;17424:165;17397:4;17391:11;17367:240;17344:5;17320:301;-1:-1:-1;;;17841:4:31;17834;17828:11;17824:22;17795:165;17768:4;17762:11;17738:240;17715:5;17691:301;18600:14;18592:4;18579:11;18575:22;18560:13;18556:42;18549:5;18536:79;19090:14;19084:4;19080:25;19073:5;19066:40;19308:14;19301:5;19297:26;19290:5;19283:41;19531:14;19524:5;19520:26;19513:5;19506:41;20092:14;20085:5;20081:26;20074:5;20067:41;20429:14;20422:5;20418:26;20620:4;20613;20603:8;20599:19;20592:33;20732:5;20725:4;20715:8;20711:19;20704:34;20831:4;20824;20814:8;20810:19;20803:33;20944:4;20937;20927:8;20923:19;20916:33;21154:5;21141:19;21135:4;21128:33;21218:4;21212;21202:21;21195:4;21185:8;21181:19;21174:50;21475:5;21468:4;21458:8;21454:19;21447:34;21587:4;21580;21570:8;21566:19;21559:33;21713:4;21705:5;21695:8;21691:20;21684:34;22067:4;22059:5;22052;22048:17;22042:4;22029:43;22184:4;22176:5;22166:8;22162:20;22155:34;22320:4;22312:5;22302:8;22298:20;22291:34;22473:4;22461:10;22457:21;22444:35;22436:5;22426:8;22422:20;22415:65;22599:4;22593;22583:21;22575:5;22565:8;22561:20;22554:51;22726:4;22718:5;22708:8;22704:20;22697:34;-1:-1:-1;;;22976:4:31;22969;22963:11;22959:22;22930:165;22903:4;22897:11;22873:240;22849:5;22839:8;22835:20;22811:316;-1:-1:-1;;;23372:4:31;23365;23359:11;23355:22;23326:165;23299:4;23293:11;23269:240;23245:5;23235:8;23231:20;23207:316;23849:4;23841:5;23831:8;23827:20;23820:34;23963:4;23955:5;23945:8;23941:20;23934:34;24312:4;24304:5;24297;24293:17;24287:4;24274:43;24497:4;24489:5;24479:8;24475:20;24468:34;24650:4;24638:10;24634:21;24621:35;24613:5;24603:8;24599:20;24592:65;24762:4;24756;24746:21;24738:5;24728:8;24724:20;24717:51;24969:4;24956:11;24952:22;24939:36;24922:53;;25055:4;25042:11;25038:22;25023:13;25019:42;25006:56;24988:74;;25190:14;25184:4;25180:25;25172:5;25162:8;25158:20;25151:55;-1:-1:-1;;;25451:4:31;25444;25438:11;25434:22;25405:165;25378:4;25372:11;25348:240;25324:5;25314:8;25310:20;25286:316;-1:-1:-1;;;25847:4:31;25840;25834:11;25830:22;25801:165;25774:4;25768:11;25744:240;25720:5;25710:8;25706:20;25682:316;26150:14;26142:4;26129:11;26125:22;26110:13;26106:42;26098:5;26088:8;26084:20;26071:94;26383:14;26377:4;26373:25;26365:5;26355:8;26351:20;26344:55;26549:14;26542:5;26538:26;26530:5;26520:8;26516:20;26509:56;26685:14;26678:5;26674:26;26664:8;26657:44;27499:5;27493:12;27476:14;27469:5;27465:26;27461:45;27454:5;27447:60;27976:4;27968:5;27962:12;27958:23;27951:5;27944:38",
  "source": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./SwapABIEncoder.sol\";\n\n/**\n * @title Swap\n * @author AZTEC\n * @dev Library to validate Swap proofs\n * Don't include this as an internal library. This contract uses\n * a static memory table to cache elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory\n * mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`. External\n * calls to OptimizedAZTEC can be treated as pure functions as this contract\n * contains no storage and makes no external calls (other than to precompiles)\n * \n * Copyright 2020 Spilsbury Holdings Ltd \n *\n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n**/\ncontract Swap {\n\n    /**\n     * @dev Swap will take any transaction sent to it and attempt to validate a zero knowledge proof.\n     * If the proof is not valid, the transaction throws.\n     * @notice See SwapInterface for how method calls should be constructed.\n     * This contract is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    // solhint-disable payable-fallback\n    function() external {\n        assembly {\n\n            // We don't check for function signatures, there's only one function that\n            // ever gets called: validateSwap()\n            // We still assume calldata is offset by 4 bytes so that we can represent\n            // this contract through a comp\\atible ABI\n            validateSwap()\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n            // and into JoinSplitABI.validateJoinSplit()\n            // reset the free memory pointer because we're touching Solidity code again\n            mstore(0x40, 0x60)\n            /**\n             * New calldata map\n             * 0x04:0x24      = calldata location of proofData byte array\n             * 0x24:0x44      = message sender // sender\n             * 0x44:0x64      = h_x     // crs\n             * 0x64:0x84      = h_y     // crs\n             * 0x84:0xa4      = t2_x0   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xc4:0xe4      = t2_y0   // crs\n             * 0xe4:0x104     = t2_y1   // crs\n             * 0x104:0x124    = length of proofData byte array\n             * 0x124:0x144    = challenge\n             * 0x144:0x164    = offset in byte array to notes\n             * 0x164:0x184    = offset in byte array to inputOwners\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n             *\n             *\n             * Note data map (uint[6]) is\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n             * 0x40:0x80       = G1 element \\gamma_i\n             * 0x80:0xc0       = G1 element \\sigma_i\n             *\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an\n             * external contract then terrible things will happen!\n             *\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n             * 0x80:0xc0       = x-coordinate of generator h\n             * 0xc0:0xe0       = y-coordinate of generator h\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1}\n             *                   concatenated with (B_i)_{i=0}^{n-1}\n             **/\n            function validateSwap() {\n                /*\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n                */\n\n                mstore(0x80, calldataload(0x44)) // h_x\n                mstore(0xa0, calldataload(0x64)) // h_y\n                let notes := add(0x104, calldataload(0x144)) // start position of notes\n                let n := calldataload(notes) // first element of the notes array is it's length\n\n                if iszero(eq(n, 0x04)) { // eq(n, 4) will resolve to 0 if n != 4\n\n                    mstore(0x00, 400) // 400 error code - due to incorrect number of notes supplied\n                    revert(0x00, 0x20)\n\n                }\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let challenge := mod(calldataload(0x124), gen_order)\n\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\n\n                hashCommitments(notes, n)\n                let b := add(0x300, mul(n, 0x80)) // set pointer to memory location of commitments where the commitments\n\n                /*\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n                */\n                let x := 1\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                    // Get the calldata index of this note and associated parameters\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n                    let k\n                    let a := calldataload(add(noteIndex, 0x20))\n                    let c := challenge\n\n                    switch gt(i, 1) // i (an indexer) > 1 denotes a taker note\n                    case 1 { // if it's a taker note\n\n                        // indexing the k value of the note that is 2 indices behind the current note\n                        k := calldataload(sub(noteIndex, 0x180))\n                    }\n\n                    case 0 { // if it's a maker note\n                        k := calldataload(noteIndex)\n                    }\n\n\n                    // Check this commitment is well formed\n                    validateCommitment(noteIndex, k, a)\n\n                    x := mulmod(x, mload(0x00), gen_order)\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = note index\n                    if gt(i, 0) {\n                        k := mulmod(k, x, gen_order)\n                        a := mulmod(a, x, gen_order)\n                        c := mulmod(challenge, x, gen_order)\n                    } \n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n                    // Memory map:\n                    // 0x20: \\gamma_iX\n                    // 0x40: \\gamma_iY\n                    // 0x60: k_i\n                    // 0x80: hX\n                    // 0xa0: hY\n                    // 0xc0: a_i\n                    // 0xe0: \\sigma_iX\n                    // 0x100: \\sigma_iY\n                    // 0x120: -c\n\n                    // loading into memory\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                    mstore(0x120, sub(gen_order, c))\n                    mstore(0x60, k)\n                    mstore(0xc0, a)\n\n                    // Call bn128 scalar multiplication precompiles\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n                    // Store \\gamma_i^{k} at 0x120:0x160\n                    // Store h^{a} at 0x160:0x1a0\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n                    // Call bn128 group addition precompiles\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                    // Store result of addition at 0x160:0x1a0\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                    // Store resulting point B at memory index b\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n                    if eq(i, 0) { // m = 0\n                        mstore(0x260, mload(0x20)) //  gamma_iX\n                        mstore(0x280, mload(0x40)) // gamma_iY\n                        mstore(0x1e0, mload(0xe0)) // sigma_iX\n                        mstore(\n                            0x200,\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\n                            )\n                    }\n\n                    // If i > 0 (i.e. all notes other than the first)\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n                    if gt(i, 0) {\n                        mstore(0x60, c)\n\n                        result := and(\n                            result,\n                            and(\n                                and(\n                                    staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40), // \\sigma_i^{-cx_{i-m-1}}\n                                    staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40) // \\gamma_i^{cx_{i-m-1}}\n                                ),\n                                staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40) // \\gamma_i^k\n                            )\n                        )\n                    }\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n                \n                validatePairing(0x84)\n\n\n                /*\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\n                */\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n                // starting at 0x2e0, of size (b - 0x2e0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n\n                if iszero(eq(expected, challenge)) {\n\n                    // No! Bad! No soup for you!\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n            }\n\n             /**        \n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n             * different trusted setups.\n             **/\n            function validatePairing(t2) {\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let t2_x_1 := calldataload(t2)\n                let t2_x_2 := calldataload(add(t2, 0x20))\n                let t2_y_1 := calldataload(add(t2, 0x40))\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n                // check provided setup pubkey is not zero or g2\n                if or(or(or(or(or(or(or(\n                    iszero(t2_x_1),\n                    iszero(t2_x_2)),\n                    iszero(t2_y_1)),\n                    iszero(t2_y_2)),\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n                {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // store coords in memory\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n                // to what precompile expects\n                // We can overwrite the memory we used previously as this function is called at the\n                // end of the validation routine.\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n                mstore(0x140, t2_x_1)\n                mstore(0x120, t2_x_2)\n                mstore(0x180, t2_y_1)\n                mstore(0x160, t2_y_2)\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n                if or(iszero(success), iszero(mload(0x20))) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\n             * throws if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                            and(\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n                                gt(a, 1)                  // can't be 0 or 1 either!\n                            ),\n                            and(\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n                                gt(k, 1)                  // and not 0 or 1\n                            )\n                        ),\n                        and(\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n                                    3,\n                                    field_order),\n                                mulmod(sigmaY, sigmaY, field_order)\n                            ),\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(gammaX, gammaX, field_order),\n                                    gammaX,\n                                    field_order),\n                                    3, field_order),\n                                mulmod(gammaY, gammaY, field_order)\n                            )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both\n             * input notes and output notes. This is used both as an input to\n             * validate the challenge `c` and also to generate pseudorandom relationships\n             * between commitments for different outputNotes, so that we can combine\n             * them into a single multi-exponentiation for the purposes of validating\n             * the bilinear pairing relationships.\n             * @param notes calldata location notes\n             * @param n number of notes\n             **/\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n                }\n                // storing at position 0x00 in memory, the kecca hash of everything from\n                // start of the commitments to the end\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n            }\n        }\n        // if we've reached here, we've validated the Swap and haven't thrown an error.\n        // Encode the output according to the ACE standard and exit.\n        SwapABIEncoder.encodeAndExit();\n    }\n}\n",
  "sourcePath": "/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/Swap.sol",
  "ast": {
    "absolutePath": "/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/Swap.sol",
    "exportedSymbols": {
      "Swap": [
        3191
      ]
    },
    "id": 3192,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 3179,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:30"
      },
      {
        "absolutePath": "/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/SwapABIEncoder.sol",
        "file": "./SwapABIEncoder.sol",
        "id": 3180,
        "nodeType": "ImportDirective",
        "scope": 3192,
        "sourceUnit": 3200,
        "src": "33:30:30",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Swap\n@author AZTEC\n@dev Library to validate Swap proofs\nDon't include this as an internal library. This contract uses\na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory\nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External\ncalls to OptimizedAZTEC can be treated as pure functions as this contract\ncontains no storage and makes no external calls (other than to precompiles)\n\n * Copyright 2020 Spilsbury Holdings Ltd \n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n * This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n * You should have received a copy of the GNU Lesser General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.*",
        "fullyImplemented": true,
        "id": 3191,
        "linearizedBaseContracts": [
          3191
        ],
        "name": "Swap",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 3189,
              "nodeType": "Block",
              "src": "1678:16404:30",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 3183,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateSwap()\n    mstore(0x40, 0x60)\n    function validateSwap()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x144))\n        let n := calldataload(notes)\n        if iszero(eq(n, 0x04))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        let x := 1\n        for { let i := 0 } lt(i, n) { i := add(i, 0x01) }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := calldataload(sub(noteIndex, 0x180))\n            }\n            case 0 { k := calldataload(noteIndex) }\n            validateCommitment(noteIndex, k, a)\n            x := mulmod(x, mload(0x00), gen_order)\n            if gt(i, 0)\n            {\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, 0)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, 0)\n            {\n                mstore(0x60, c)\n                result := and(result, and(and(staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40), staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40)), staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40)))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for { let i := 0 } lt(i, n) { i := add(i, 0x01) }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1688:16191:30"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 3184,
                        "name": "SwapABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 3199,
                        "src": "18045:14:30",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_SwapABIEncoder_$3199_$",
                          "typeString": "type(library SwapABIEncoder)"
                        }
                      },
                      "id": 3186,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 3198,
                      "src": "18045:28:30",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 3187,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "18045:30:30",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 3188,
                  "nodeType": "ExpressionStatement",
                  "src": "18045:30:30"
                }
              ]
            },
            "documentation": "@dev Swap will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction throws.\n@notice See SwapInterface for how method calls should be constructed.\nThis contract is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 3190,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 3181,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1666:2:30"
            },
            "returnParameters": {
              "id": 3182,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1678:0:30"
            },
            "scope": 3191,
            "src": "1658:16424:30",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 3192,
        "src": "1235:16849:30"
      }
    ],
    "src": "0:18085:30"
  },
  "legacyAST": {
    "attributes": {
      "absolutePath": "/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/Swap.sol",
      "exportedSymbols": {
        "Swap": [
          3191
        ]
      }
    },
    "children": [
      {
        "attributes": {
          "literals": [
            "solidity",
            ">=",
            "0.5",
            ".0",
            "<",
            "0.6",
            ".0"
          ]
        },
        "id": 3179,
        "name": "PragmaDirective",
        "src": "0:31:30"
      },
      {
        "attributes": {
          "SourceUnit": 3200,
          "absolutePath": "/Users/suleymankardas/Desktop/aztec/aztec-protocol/contracts/ACE/validators/swap/SwapABIEncoder.sol",
          "file": "./SwapABIEncoder.sol",
          "scope": 3192,
          "symbolAliases": [
            null
          ],
          "unitAlias": ""
        },
        "id": 3180,
        "name": "ImportDirective",
        "src": "33:30:30"
      },
      {
        "attributes": {
          "baseContracts": [
            null
          ],
          "contractDependencies": [
            null
          ],
          "contractKind": "contract",
          "documentation": "@title Swap\n@author AZTEC\n@dev Library to validate Swap proofs\nDon't include this as an internal library. This contract uses\na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory\nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External\ncalls to OptimizedAZTEC can be treated as pure functions as this contract\ncontains no storage and makes no external calls (other than to precompiles)\n\n * Copyright 2020 Spilsbury Holdings Ltd \n * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\");\nyou may not use this file except in compliance with the License.\n * This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n * You should have received a copy of the GNU Lesser General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.*",
          "fullyImplemented": true,
          "linearizedBaseContracts": [
            3191
          ],
          "name": "Swap",
          "scope": 3192
        },
        "children": [
          {
            "attributes": {
              "documentation": "@dev Swap will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction throws.\n@notice See SwapInterface for how method calls should be constructed.\nThis contract is written in YUL to enable manual memory management and for other efficiency savings.*",
              "implemented": true,
              "isConstructor": false,
              "kind": "fallback",
              "modifiers": [
                null
              ],
              "name": "",
              "scope": 3191,
              "stateMutability": "nonpayable",
              "superFunction": null,
              "visibility": "external"
            },
            "children": [
              {
                "attributes": {
                  "parameters": [
                    null
                  ]
                },
                "children": [],
                "id": 3181,
                "name": "ParameterList",
                "src": "1666:2:30"
              },
              {
                "attributes": {
                  "parameters": [
                    null
                  ]
                },
                "children": [],
                "id": 3182,
                "name": "ParameterList",
                "src": "1678:0:30"
              },
              {
                "children": [
                  {
                    "attributes": {
                      "externalReferences": [
                        null
                      ],
                      "operations": "{\n    validateSwap()\n    mstore(0x40, 0x60)\n    function validateSwap()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x144))\n        let n := calldataload(notes)\n        if iszero(eq(n, 0x04))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        let x := 1\n        for { let i := 0 } lt(i, n) { i := add(i, 0x01) }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := calldataload(sub(noteIndex, 0x180))\n            }\n            case 0 { k := calldataload(noteIndex) }\n            validateCommitment(noteIndex, k, a)\n            x := mulmod(x, mload(0x00), gen_order)\n            if gt(i, 0)\n            {\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, 0)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, 0)\n            {\n                mstore(0x60, c)\n                result := and(result, and(and(staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40), staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40)), staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40)))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for { let i := 0 } lt(i, n) { i := add(i, 0x01) }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}"
                    },
                    "children": [],
                    "id": 3183,
                    "name": "InlineAssembly",
                    "src": "1688:16191:30"
                  },
                  {
                    "children": [
                      {
                        "attributes": {
                          "argumentTypes": null,
                          "arguments": [
                            null
                          ],
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "isStructConstructorCall": false,
                          "lValueRequested": false,
                          "names": [
                            null
                          ],
                          "type": "tuple()",
                          "type_conversion": false
                        },
                        "children": [
                          {
                            "attributes": {
                              "argumentTypes": [
                                null
                              ],
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "member_name": "encodeAndExit",
                              "referencedDeclaration": 3198,
                              "type": "function () pure"
                            },
                            "children": [
                              {
                                "attributes": {
                                  "argumentTypes": null,
                                  "overloadedDeclarations": [
                                    null
                                  ],
                                  "referencedDeclaration": 3199,
                                  "type": "type(library SwapABIEncoder)",
                                  "value": "SwapABIEncoder"
                                },
                                "id": 3184,
                                "name": "Identifier",
                                "src": "18045:14:30"
                              }
                            ],
                            "id": 3186,
                            "name": "MemberAccess",
                            "src": "18045:28:30"
                          }
                        ],
                        "id": 3187,
                        "name": "FunctionCall",
                        "src": "18045:30:30"
                      }
                    ],
                    "id": 3188,
                    "name": "ExpressionStatement",
                    "src": "18045:30:30"
                  }
                ],
                "id": 3189,
                "name": "Block",
                "src": "1678:16404:30"
              }
            ],
            "id": 3190,
            "name": "FunctionDefinition",
            "src": "1658:16424:30"
          }
        ],
        "id": 3191,
        "name": "ContractDefinition",
        "src": "1235:16849:30"
      }
    ],
    "id": 3192,
    "name": "SourceUnit",
    "src": "0:18085:30"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.17+commit.d19bba13.Emscripten.clang"
  },
  "networks": {
    "3500": {
      "events": {},
      "links": {},
      "address": "0x99907b58b29b00Da1b82eC9CAa9a586b06C3773c",
      "transactionHash": "0xa5bdf8595ac8d5178e8f9ad7ab35665f153c4ceb70b1dea9ae7e3ceb18b2efc1"
    }
  },
  "schemaVersion": "3.4.1",
  "updatedAt": "2022-03-28T14:54:51.579Z",
  "networkType": "ethereum",
  "devdoc": {
    "author": "AZTEC",
    "details": "Library to validate Swap proofs Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes. Calling this internally from another function will lead to memory mutation and undefined behaviour. The intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)  * Copyright 2020 Spilsbury Holdings Ltd  * Licensed under the GNU Lesser General Public Licence, Version 3.0 (the \"License\"); you may not use this file except in compliance with the License. * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details. * You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.*",
    "methods": {},
    "title": "Swap"
  },
  "userdoc": {
    "methods": {}
  }
}